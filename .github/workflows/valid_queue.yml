# This workflow validates that the appropriate tests have passed before merging:
# - On pull_request: passes if the pytest job passes
# - On merge_group: passes if the integration_tests job passes

name: Validity Check

on:
  pull_request:
    types: [opened, synchronize, reopened]
  merge_group:

jobs:
  check:
    name: Validate test requirements
    runs-on: ubuntu-latest

    steps:
      - name: Wait for and check required workflow
        uses: actions/github-script@v7
        with:
          script: |
            const eventName = context.eventName;

            if (eventName === 'pull_request') {
              // For PRs, check if the pytest job has passed
              const workflowName = 'Code Quality and Testing';
              const jobName = 'pytest';

              core.info(`Checking for workflow: ${workflowName}, job: ${jobName}`);

              // Get the current commit SHA
              const sha = context.payload.pull_request.head.sha;

              // List all workflow runs for this commit
              const runs = await github.rest.actions.listWorkflowRunsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head_sha: sha,
                per_page: 100
              });

              const targetRun = runs.data.workflow_runs.find(run => run.name === workflowName);

              if (!targetRun) {
                core.setFailed(`Workflow "${workflowName}" not found for this commit`);
                return;
              }

              // Wait for the workflow to complete (with timeout)
              const maxWaitTime = 60 * 60 * 1000; // 1 hour
              const pollInterval = 30000; // 30 seconds
              const startTime = Date.now();

              let currentRun = targetRun;

              while (currentRun.status !== 'completed') {
                if (Date.now() - startTime > maxWaitTime) {
                  core.setFailed('Timeout waiting for workflow to complete');
                  return;
                }

                core.info(`Waiting for workflow to complete... Status: ${currentRun.status}`);
                await new Promise(resolve => setTimeout(resolve, pollInterval));

                const updatedRun = await github.rest.actions.getWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: currentRun.id
                });

                currentRun = updatedRun.data;
              }

              // Get jobs for the workflow run
              const jobs = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: currentRun.id
              });

              const pytestJobs = jobs.data.jobs.filter(job => job.name.startsWith(jobName));

              if (pytestJobs.length === 0) {
                core.setFailed(`No jobs found matching "${jobName}"`);
                return;
              }

              const allPassed = pytestJobs.every(job => job.conclusion === 'success');

              if (!allPassed) {
                const failedJobs = pytestJobs.filter(job => job.conclusion !== 'success');
                core.setFailed(`pytest jobs failed: ${failedJobs.map(j => j.name).join(', ')}`);
              } else {
                core.info(`All pytest jobs passed`);
              }

            } else if (eventName === 'merge_group') {
              // For merge queue, check if integration_tests job has passed
              const workflowName = 'nightly-ci-integration-tests';
              const jobName = 'integration_tests';

              core.info(`Checking for workflow: ${workflowName}, job: ${jobName}`);

              // Get the current commit SHA
              const sha = context.payload.merge_group.head_sha;

              // List all workflow runs for this commit
              const runs = await github.rest.actions.listWorkflowRunsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                head_sha: sha,
                per_page: 100
              });

              const targetRun = runs.data.workflow_runs.find(run => run.name === workflowName);

              if (!targetRun) {
                core.setFailed(`Workflow "${workflowName}" not found for this commit`);
                return;
              }

              // Wait for the workflow to complete (with timeout)
              const maxWaitTime = 60 * 60 * 1000; // 1 hour
              const pollInterval = 30000; // 30 seconds
              const startTime = Date.now();

              let currentRun = targetRun;

              while (currentRun.status !== 'completed') {
                if (Date.now() - startTime > maxWaitTime) {
                  core.setFailed('Timeout waiting for workflow to complete');
                  return;
                }

                core.info(`Waiting for workflow to complete... Status: ${currentRun.status}`);
                await new Promise(resolve => setTimeout(resolve, pollInterval));

                const updatedRun = await github.rest.actions.getWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: currentRun.id
                });

                currentRun = updatedRun.data;
              }

              // Get jobs for the workflow run
              const jobs = await github.rest.actions.listJobsForWorkflowRun({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: currentRun.id
              });

              const integrationJob = jobs.data.jobs.find(job => job.name === jobName);

              if (!integrationJob) {
                core.setFailed(`Job "${jobName}" not found in workflow`);
                return;
              }

              if (integrationJob.conclusion !== 'success') {
                core.setFailed(`Integration tests failed with conclusion: ${integrationJob.conclusion}`);
              } else {
                core.info(`Integration tests passed`);
              }
            }
