defaults:
- data: zarr
- dataloader: native_grid
- datamodule: single
- diagnostics: evaluation
- hardware: example
- graph: multi_scale
- model: transformer
- training: interpolator
- _self_

config_validation: True

data:
  frequency: 1h
  timestep: 1h
  resolution: o96

  forcing:
  - "cos_latitude"
  - "cos_longitude"
  - "sin_latitude"
  - "sin_longitude"
  - "cos_julian_day"
  - "cos_local_time"
  - "sin_julian_day"
  - "sin_local_time"
  - "insolation"
  - "lsm"
  - "sdor"
  - "slor"
  - "z"
  - "tp_accum"
  - "cp_accum"
  # features that are only part of the forecast state
  # but are not used as the input to the model
  diagnostic: ['tp','cp']

  normalizer:
    default: "mean-std"

    # Remap cp statistics to those of tp when using FractionBounding. This ensures
    # that cp, as a fraction of tp, remains consistent with tp's scale and statistics.
    # NOTE: This remap should only be applied if FractionBounding is enabled for cp.
    remap:
      tp: tp_accum
      cp: cp_accum

    # Standardization applied to tp and cp variables. Ensure that if cp is bounded
    # as a fraction of tp, both variables are normalized using these shared statistics.
    # "Std" normalization is preferred here over "mean-std" to avoid shifting of the
    # zero value in the normalized space.
    std:
    - "tp"
    - "cp"
    - "tp_accum"
    - "cp_accum"

    min-max:
    max:
    - "sdor"
    - "slor"
    - "z"
    none:
    - "cos_latitude"
    - "cos_longitude"
    - "sin_latitude"
    - "sin_longitude"
    - "cos_julian_day"
    - "cos_local_time"
    - "sin_julian_day"
    - "sin_local_time"
    - "insolation"
    - "lsm"

  # processors including imputers and normalizers are applied in order of definition
  processors:
    normalizer:
      _target_: anemoi.models.preprocessing.normalizer.InputNormalizer
      config: ${data.normalizer}
    # const_imputer:
    #   _target_: anemoi.models.preprocessing.imputer.ConstantImputer
    #   config: ${data.const_imputer}

    set_to_zero:
      _target_: anemoi.models.preprocessing.overwriter.SetToZero
      config:
        - vars:
            - "tp_accum"
            - "cp_accum"
          time_index: [0]

#dataloader:
  # model_run_info: #Add for non-analysis training
  #  start: 2020-02-05T12:00:00
  #  length: 18 #in number of dates (* frequency for actual time)

model:
  model:
    _target_: anemoi.models.models.interpolator.AnemoiModelEncProcDecInterpolator
  latent_skip: False # True/False for skip connection on latent mesh
  grid_skip: 0 # Which of the input indices to use as residual connection, null if none.



  # Mass-conserving accumulations
  # Ensure each predicted interpolated target sums to its accumulated forcing input.
  # The sum of predicted targets at `training.explicit_times.target` (with step `data.frequency`)
  #   should match the accumulated input at `training.explicit_times.input[-1]` e.g. the r.h.s of the accumulation input
  # Requirements:
  # - In config.data: targets must be listed under `diagnostic`; accumulation inputs under `forcing`.
  # - Use the `set_to_zero` processor to zero the left boundary (time_index=0) of each accumulation input,
  mass_conserving_accumulations:
    tp : tp_accum
    cp : cp_accum

training:

  explicit_times:
    input: [0,6]
    target: [1,2,3,4,5]

  target_forcing: #forcing parameters for the target time to include as input
    data: #of which come from the dataset
      - "insolation"
    time_fraction: True

diagnostics:
  log:
    mlflow:
      max_params_length: 3000

  plot: # Callbacks are currently not supported for interpolator
    callbacks: []
    colormaps: {}
